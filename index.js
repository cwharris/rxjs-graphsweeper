// Generated by CoffeeScript 1.4.0
(function() {
  var Minefield, MinefieldLink, MinefieldLinkView, MinefieldNode, MinefieldNodeView, MinefieldUnit, SpokeGraph;

  SpokeGraph = (function() {

    function SpokeGraph(options) {
      var defaults, i, layerNumber, nodeB, prevLayer, self, x, _i, _j, _ref, _ref1;
      this.options = options != null ? options : {};
      self = this;
      this.nodes = [];
      this.links = [];
      defaults = {
        numSpokes: 6,
        numLayers: 6,
        generateCenter: false,
        nodeFunc: function(data, dispose) {
          console.log('node', data);
          return data;
        },
        linkFunc: function(a, b) {
          console.log('link', a, b);
          return {
            a: a,
            b: b
          };
        }
      };
      for (x in defaults) {
        this.options[x] = this.options[x] || defaults[x];
      }
      prevLayer = null;
      for (layerNumber = _i = 1, _ref = this.options.numLayers; _i <= _ref; layerNumber = _i += 1) {
        prevLayer = this.makeLayer(layerNumber, prevLayer);
      }
      if (this.options.generateCenter) {
        (function() {
          var data, nodeA;
          data = {
            numSpokes: self.options.numSpokes,
            numLayers: self.options.numLayers,
            layerNumber: 0,
            spokeNumber: 0,
            branchLength: 1,
            branchIndex: 0
          };
          nodeA = self.options.nodeFunc(data, function() {
            return self.removeNode(nodeA);
          });
          return self.nodes.push(nodeA);
        })();
        for (i = _j = 0, _ref1 = this.options.numSpokes; _j < _ref1; i = _j += 1) {
          nodeB = this.nodes[i];
          this.links.push(this.options.linkFunc(nodeA, nodeB));
        }
      }
    }

    SpokeGraph.prototype.makeLayer = function(layerNumber, prevLayer) {
      var branch, branchA, branchB, branches, i, link, links, nodeA, nodeB, nodes, prevBranch, spokeNumber, _i, _j, _k, _len, _len1, _ref;
      nodes = [];
      links = [];
      branches = [];
      for (spokeNumber = _i = 0, _ref = this.options.numSpokes; _i < _ref; spokeNumber = _i += 1) {
        if (prevLayer) {
          prevBranch = prevLayer.branches[spokeNumber];
        }
        branch = this.makeBranch(layerNumber, spokeNumber, prevBranch);
        branches.push(branch);
        nodes = _.union(nodes, branch.nodes);
        links = _.union(links, branch.links);
      }
      for (i = _j = 0, _len = branches.length; _j < _len; i = ++_j) {
        branchA = branches[i];
        branchB = branches[(i + 1) % branches.length];
        nodeA = _.last(branchA.nodes);
        nodeB = _.first(branchB.nodes);
        link = this.options.linkFunc(nodeA, nodeB);
        links.push(link);
        this.links.push(link);
      }
      if (prevLayer) {
        for (i = _k = 0, _len1 = branches.length; _k < _len1; i = ++_k) {
          branchA = branches[i];
          branchB = prevLayer.branches[(i + 1) % prevLayer.branches.length];
          nodeA = _.last(branchA.nodes);
          nodeB = _.first(branchB.nodes);
          link = this.options.linkFunc(nodeA, nodeB);
          links.push(link);
          this.links.push(link);
        }
      }
      return {
        nodes: nodes,
        links: links,
        branches: branches
      };
    };

    SpokeGraph.prototype.makeBranch = function(layerNumber, spokeNumber, prevBranch, length) {
      var i, link, links, nodeA, nodeB, nodeC, nodes, self, _fn, _i, _j, _k, _len, _ref, _ref1;
      if (length == null) {
        length = layerNumber;
      }
      self = this;
      nodes = [];
      links = [];
      _fn = function() {
        var data, node;
        data = {
          numSpokes: self.options.numSpokes,
          numLayers: self.options.numLayers,
          layerNumber: layerNumber,
          spokeNumber: spokeNumber,
          branchLength: length,
          branchIndex: i
        };
        node = self.options.nodeFunc(data, function() {
          return self.removeNode(node);
        });
        nodes.push(node);
        return self.nodes.push(node);
      };
      for (i = _i = 0; _i < length; i = _i += 1) {
        _fn();
      }
      for (i = _j = 0, _ref = nodes.length - 1; _j < _ref; i = _j += 1) {
        nodeA = nodes[i];
        nodeB = nodes[(i + 1) % nodes.length];
        link = this.options.linkFunc(nodeA, nodeB);
        links.push(link);
        this.links.push(link);
      }
      if (prevBranch) {
        _ref1 = prevBranch.nodes;
        for (i = _k = 0, _len = _ref1.length; _k < _len; i = ++_k) {
          nodeA = _ref1[i];
          nodeB = nodes[i];
          nodeC = nodes[i + 1];
          link = this.options.linkFunc(nodeA, nodeB);
          links.push(link);
          this.links.push(link);
          link = this.options.linkFunc(nodeA, nodeC);
          links.push(link);
          this.links.push(link);
        }
      }
      return {
        removeNode: function(node) {
          this.nodes = _.without(this.nodes, node);
          return this.links = _.filter(this.links, function(link) {
            return link.a !== node && link.b !== node;
          });
        },
        nodes: nodes,
        links: links
      };
    };

    return SpokeGraph;

  })();

  MinefieldUnit = (function() {

    function MinefieldUnit() {
      this.disposer = new Rx.CompositeDisposable;
      this.disposer.add(this.isCovered = new Rx.BehaviorSubject(true));
      this.disposer.add(this.isBomb = new Rx.BehaviorSubject(false));
      this.disposer.add(this.isFlagged = new Rx.BehaviorSubject(false));
      this.disposer.add(this.flag = new Rx.BehaviorSubject('certain'));
      this.disposer.add(this.numBombs = new Rx.BehaviorSubject(0));
      this.friends = [];
    }

    MinefieldUnit.prototype.addFriend = function(friend) {
      var self;
      self = this;
      this.friends.push(friend);
      return this.disposer.add(friend.isBomb.skipWhile(function(x) {
        return !x;
      }).subscribe(function(x) {
        return self.numBombs.onNext(self.numBombs.value + (x ? 1 : -1));
      }));
    };

    MinefieldUnit.prototype.dispose = function() {
      return this.disposer.dispose();
    };

    return MinefieldUnit;

  })();

  MinefieldLink = (function() {

    function MinefieldLink(a, b) {
      this.a = a;
      this.b = b;
      this.a.unit.addFriend(this.b.unit);
      this.b.unit.addFriend(this.a.unit);
      this.spring = new Spring(this.a.particle, this.b.particle, 40, 0.5);
      this.view = new MinefieldLinkView(this);
    }

    return MinefieldLink;

  })();

  MinefieldNode = (function() {

    function MinefieldNode(data) {
      this.unit = new MinefieldUnit;
      this.particle = MinefieldNode.makeParticle(data);
      this.view = new MinefieldNodeView(this.unit, this.particle);
    }

    MinefieldNode.makeParticle = function(data) {
      var a, b, distance, lerp, particle;
      distance = data.layerNumber * 50;
      a = (function() {
        var spokeAngle, x, y;
        spokeAngle = data.spokeNumber / data.numSpokes * Math.PI * 2;
        x = distance * Math.cos(spokeAngle);
        y = distance * Math.sin(spokeAngle);
        return new Vector(x, y);
      })();
      b = (function() {
        var spokeAngle, x, y;
        spokeAngle = (data.spokeNumber + 1) / data.numSpokes * Math.PI * 2;
        x = distance * Math.cos(spokeAngle);
        y = distance * Math.sin(spokeAngle);
        return new Vector(x, y);
      })();
      lerp = function(a, b, amount) {
        var x, y;
        x = a.x + (b.x - a.x) * amount;
        y = a.y + (b.y - a.y) * amount;
        return new Vector(x, y);
      };
      particle = new Particle;
      particle.pos = lerp(a, b, data.branchIndex / data.branchLength);
      return particle;
    };

    return MinefieldNode;

  })();

  MinefieldNodeView = (function() {

    function MinefieldNodeView(unit, particle) {
      this.unit = unit;
      this.particle = particle;
    }

    MinefieldNodeView.prototype.draw = function(ctx) {
      var text, xOffset;
      ctx.shadowColor = 'black';
      ctx.shadowBlur = 0;
      if (!this.unit.isCovered.value && this.unit.numBombs.value === 0 && !this.unit.isBomb.value) {
        return;
      }
      if (this.unit.isCovered.value) {
        if (this.unit.isFlagged.value) {
          ctx.fillStyle = 'rgba(255,255,255,1)';
          ctx.shadowBlur = 5;
          ctx.shadowColor = 'rgba(125,125,255,1)';
        } else {
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
        }
      } else {
        ctx.fillStyle = 'rgba(255,255,255,1)';
      }
      ctx.beginPath();
      ctx.arc(this.particle.pos.x, this.particle.pos.y, this.particle.mass * 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      if (this.unit.isCovered.value) {
        if (this.unit.isFlagged.value) {
          ctx.fillStyle = 'rgba(125,125,255,1)';
        } else {
          ctx.fillStyle = 'rgba(255,255,255,1)';
        }
      } else if (this.unit.isBomb.value) {
        ctx.fillStyle = 'rgba(0,0,0,1)';
      } else {
        ctx.fillStyle = 'rgba(255,255,255,1)';
      }
      ctx.beginPath();
      ctx.arc(this.particle.pos.x, this.particle.pos.y, this.particle.mass * 10, 0, Math.PI * 2);
      ctx.fill();
      if (this.unit.numBombs.value > 0 && !this.unit.isBomb.value && !this.unit.isCovered.value) {
        text = this.unit.numBombs.value.toString();
        xOffset = ctx.measureText(text).width / 2;
        ctx.textBaseline = "middle";
        ctx.font = '12pt sans-serif';
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        return ctx.fillText(text, this.particle.pos.x - xOffset, this.particle.pos.y + 1);
      }
    };

    return MinefieldNodeView;

  })();

  MinefieldLinkView = (function() {

    function MinefieldLinkView(link) {
      this.link = link;
    }

    MinefieldLinkView.prototype.draw = function(ctx) {
      var p1, p2;
      p1 = this.link.a.particle;
      p2 = this.link.b.particle;
      if (this.link.a.unit.isCovered.value || this.link.b.unit.isCovered.value || this.link.a.unit.isBomb.value || this.link.b.unit.isBomb.value) {
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.beginPath();
        ctx.moveTo(p1.pos.x, p1.pos.y);
        ctx.lineTo(p2.pos.x, p2.pos.y);
        return ctx.stroke();
      }
    };

    return MinefieldLinkView;

  })();

  Minefield = (function() {

    function Minefield(graph, numMines) {
      var disposer, node, self, _fn, _i, _len, _ref;
      this.graph = graph;
      this.numMines = numMines != null ? numMines : 10;
      self = this;
      this.reveals = Rx.Observable.empty();
      _ref = graph.nodes;
      _fn = function() {
        var a;
        a = node;
        return self.reveals = self.reveals.merge(node.unit.isCovered.where(function(x) {
          return !x;
        }).select(function() {
          return a;
        }));
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        _fn();
      }
      disposer = new Rx.CompositeDisposable;
      disposer.add(this.reveals.take(1).subscribe(function(node) {
        var unit, units, _j, _len1, _results;
        units = _.map(self.graph.nodes, function(node) {
          return node.unit;
        });
        units = _.without(units, node.unit);
        units = _.difference(units, node.unit.friends);
        units = _.shuffle(units);
        units = _.first(units, self.numMines);
        _results = [];
        for (_j = 0, _len1 = units.length; _j < _len1; _j++) {
          unit = units[_j];
          _results.push(unit.isBomb.onNext(true));
        }
        return _results;
      }));
      disposer.add(this.reveals.where(function(node) {
        return node.unit.numBombs.value === 0;
      }).delay(25).subscribe(function(node) {
        var unit, units, _j, _len1, _results;
        units = _.filter(node.unit.friends, function(friend) {
          return friend.isCovered.value;
        });
        _results = [];
        for (_j = 0, _len1 = units.length; _j < _len1; _j++) {
          unit = units[_j];
          _results.push(unit.isCovered.onNext(false));
        }
        return _results;
      }));
      disposer.add(this.reveals.where(function(node) {
        return node.unit.isBomb.value;
      }).delay(100).subscribe(function() {
        disposer.dispose();
        return alert('YOU LOSE');
      }));
    }

    return Minefield;

  })();

  $(function() {
    return (function() {
      var release;
      release = $(document).onAsObservable('mouseup');
      jQuery.fn.tapAsObservable = function() {
        var target;
        target = $(this);
        return target.onAsObservable('mousedown').selectMany(function(e) {
          return target.onAsObservable('mouseup').select(function() {
            return e;
          }).take(1).takeUntil(Rx.Observable.interval(250));
        });
      };
      return jQuery.fn.longPressAsObservable = function() {
        var target;
        target = $(this);
        return target.onAsObservable('mousedown').selectMany(function(e) {
          return Rx.Observable.returnValue(e).delay(250).takeUntil(release);
        });
      };
    })();
  });

  $(function() {
    var $window, canvas, ctx, field, getClosestNode, graph, physics, t, update;
    $window = $(window);
    $window.onAsObservable('resize').subscribe(function() {
      return $('canvas').attr({
        width: $window.width(),
        height: $window.height()
      });
    });
    $window.resize();
    physics = new Physics;
    graph = null;
    (function() {
      var link, node, particle, spring, _i, _j, _len, _len1, _ref, _ref1, _results;
      graph = new SpokeGraph({
        numSpokes: 10,
        numLayers: 7,
        nodeFunc: function(data) {
          return new MinefieldNode(data);
        },
        linkFunc: function(a, b) {
          return new MinefieldLink(a, b);
        }
      });
      _ref = graph.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        particle = node.particle;
        physics.particles.push(particle);
      }
      _ref1 = graph.links;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        link = _ref1[_j];
        spring = link.spring;
        _results.push(physics.springs.push(spring));
      }
      return _results;
    })();
    field = new Minefield(graph, 40);
    getClosestNode = function(nodes, pos) {
      pos = new Vector(pos.x - $(window).width() / 2, pos.y - $(window).height() / 2);
      nodes = _.sortBy(nodes, function(node) {
        var dist;
        dist = node.particle.pos.dist(pos);
        return dist;
      });
      return nodes[0];
    };
    $('canvas').tapAsObservable().select(function(e) {
      return new Vector(e.pageX, e.pageY);
    }).select(function(pos) {
      return getClosestNode(graph.nodes, pos);
    }).where(function(node) {
      return !node.unit.isFlagged.value;
    }).subscribe(function(node) {
      return node.unit.isCovered.onNext(false);
    });
    $('canvas').tapAsObservable().select(function(e) {
      return new Vector(e.pageX, e.pageY);
    }).select(function(pos) {
      return getClosestNode(graph.nodes, pos);
    }).where(function(node) {
      return !node.unit.isCovered.value;
    }).where(function(node) {
      return node.unit.numBombs.value > 0;
    }).where(function(node) {
      var flags;
      flags = _.filter(node.unit.friends, function(friend) {
        return friend.isFlagged.value;
      });
      return node.unit.numBombs.value === flags.length;
    }).subscribe(function(node) {
      var nonBombFriends;
      nonBombFriends = _.filter(node.unit.friends, function(friend) {
        return !friend.isFlagged.value;
      });
      return _.each(nonBombFriends, function(friend) {
        return friend.isCovered.onNext(false);
      });
    });
    $('canvas').longPressAsObservable().select(function(e) {
      return new Vector(e.pageX, e.pageY);
    }).select(function(pos) {
      return getClosestNode(graph.nodes, pos);
    }).subscribe(function(node) {
      return node.unit.isFlagged.onNext(!node.unit.isFlagged.value);
    });
    canvas = $('canvas')[0];
    ctx = canvas.getContext('2d');
    t = 0;
    update = function(timestamp) {
      var dt, link, node, _i, _j, _len, _len1, _ref, _ref1;
      dt = (timestamp - t) / 1000;
      t = timestamp;
      if (!isFinite(dt)) {
        return requestAnimationFrame(update);
      }
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.translate($window.width() / 2, $window.height() / 2);
      physics.step();
      _ref = graph.links;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        link = _ref[_i];
        link.view.draw(ctx);
      }
      _ref1 = graph.nodes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        node = _ref1[_j];
        node.view.draw(ctx);
      }
      return requestAnimationFrame(update);
    };
    return update();
  });

}).call(this);
